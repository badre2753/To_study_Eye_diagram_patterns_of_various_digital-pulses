<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BFSK Modulation System with Input Enforcement</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h1 {
            margin-bottom: 10px;
        }

        #kit {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1400px;
            width: 100%;
            position: relative;
        }

        .module {
            background: #fff;
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            width: 280px;
            box-sizing: border-box;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .module h2 {
            font-size: 18px;
            margin: 0 0 10px 0;
            text-align: center;
        }

        .ports-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .port-block {
            text-align: center;
        }

        .port-label {
            font-size: 12px;
            margin-top: 4px;
        }

        .port {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 auto;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .port:hover {
            transform: scale(1.2);
        }

        .port.selected {
            transform: scale(1.3);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .input-port {
            background-color: black;
            border: 1.5px solid #333;
        }

        .output-port {
            background-color: red;
            border: 1.5px solid #800;
        }

        button {
            background-color: green;
            color: white;
            font-weight: bold;
            border: none;
            padding: 6px 10px;
            margin: 4px;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
            font-size: 14px;
            transition: transform 0.1s ease;
        }


        #powerBtn.off {
            background-color: #f44336; /* Red when off */
        }

        #powerBtn.on {
            background-color: #4CAF50; /* Green when on */
        }

        /* Container holds image + box */
        .device {
            width: 320px;
            margin: 40px auto;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            background-color: #fff;
            font-family: Arial, sans-serif;
        }

        /* Top image fits perfectly and touches the box */
        .device-image {
            width: 100%;
            display: block;
            margin-bottom: -4px; /* No gap between image and box */
        }

        /* Box styling */
        .box {
            padding: 20px;
            background-color: #f0f0f0;
            text-align: center;
            border-top: 2px solid #000;
        }

        /* Inputs and Buttons inside box */
        .box input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .box button {
            padding: 10px 20px;
            border: none;
            background-color: #007BFF;
            color: white;
            font-size: 14px;
            border-radius: 6px;
            cursor: pointer;
        }

        .box button:hover {
            background-color: #0056b3;
        }

        .device {
            max-width: 100%;
            width: 320px;
        }

        button:active {
            transform: scale(0.9);
        }

        .control-group {
            text-align: center;
            margin-bottom: 10px;
        }

        .control-label {
            margin-bottom: 6px;
            font-weight: 600;
        }

        #binaryInput {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        #binaryInput label {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
        }

        #binaryInput input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        canvas#bfskCanvas {
            margin-top: 20px;
            background: white;
            border: 2px solid #666;
            border-radius: 8px;
            display: none;
        }

        .connection {
            position: absolute;
            background-color: #2196F3;
            height: 3px;
            transform-origin: 0 0;
            z-index: 0;
            pointer-events: none;
        }

        .temp-connection {
            position: absolute;
            background-color: #FF9800;
            height: 3px;
            transform-origin: 0 0;
            z-index: 2;
            pointer-events: none;
        }

        .connection-label {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            color: #333;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        #statusMessage {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f44336;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            display: none;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #bfskOutput {
            margin-top: 20px;
            font-weight: bold;
            color: #333;
            padding: 10px;
            border: 1px solid #666;
            border-radius: 5px;
            background: #f5f5f5;
        }

        /* Oscilloscope modal styles */
        #oscilloscopeModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        #oscilloscopeContent {
            background-color: #222;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            position: relative;
            box-sizing: border-box;
        }
        
        #oscilloscopeClose {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        
        #oscilloscopeDisplay {
            width: 100%;
            height: 300px;
            background-color: black;
            border: 2px solid #444;
            border-radius: 5px;
            margin-top: 20px;
            display: block;
        }

        .waveform-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .waveform-option {
            display: flex;
            align-items: center;
            color: white;
        }

        .waveform-option input {
            margin-right: 10px;
        }

        .box-image {
  width: 101%;        /* make image fit inside box */
  height: auto;
  margin-bottom: 3px;
}

        /* Responsive */
        @media (max-width: 600px) {
            .module {
                width: 100%;
                max-width: 350px;
            }
        }
    </style>
</head>

<body>

    <h1>BFSK Modulation System with Input Enforcement</h1>

    <button id="powerBtn">Power ON</button>
    <button id="resetConnectionsBtn">Reset Connections</button>
    <button id="showOscilloscopeBtn">Show on Oscilloscope</button>

    <div id="statusMessage">Invalid connection!</div>

    <!-- Oscilloscope Modal -->
    <div id="oscilloscopeModal">
        <div id="oscilloscopeContent">
            <span id="oscilloscopeClose">&times;</span>
            <h2 style="color: white; text-align: center;">Oscilloscope Display</h2>
            
            <div class="waveform-selector">
                <div class="waveform-option">
                    <input type="radio" id="inputWave" name="waveform" value="input" checked>
                    <label for="inputWave">Input Binary Signal (NRZ)</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="funcGen1Wave" name="waveform" value="func1">
                    <label for="funcGen1Wave">Function Generator 1 (Mark Frequency)</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="funcGen2Wave" name="waveform" value="func2">
                    <label for="funcGen2Wave">Function Generator 2 (Space Frequency)</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="outputWave" name="waveform" value="output">
                    <label for="outputWave">BFSK Output Signal</label>
                </div>
            </div>
            
            <canvas id="oscilloscopeDisplay"></canvas>
        </div>
    </div>

    <div id="kit">

        <!-- Function Generator 1 -->
        
        <div class="module" id="funcGen1">
             <div class="box">
            <img src="images/image.png" class="box-image" alt="Function Generator">
            </div>
            <h2>Function Generator 1</h2>
            <div class="ports-row">
                <div class="port-block"></div>
                <div class="port-block"></div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="funcGen1" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">Frequency: <span id="funcFreq1Val">2</span> MHz</div>
                <button onclick="changeFrequency('func1', -0.5)" id="func1FreqDownBtn">-</button>
                <button onclick="changeFrequency('func1', 0.5)" id="func1FreqUpBtn">+</button>
            </div>
            <div class="control-group">
                <div class="control-label">Amplitude: <span id="funcAmp1Val">15</span> V</div>
                <button onclick="changeAmplitude('func1', -1)" id="func1AmpDownBtn">-</button>
                <button onclick="changeAmplitude('func1', 1)" id="func1AmpUpBtn">+</button>
            </div>
        </div>

        <!-- Function Generator 2 -->
        <div class="module" id="funcGen2">
             <div class="box">
            <img src="images/image.png" class="box-image" alt="Function Generator">
            </div>
            <h2>Function Generator 2</h2>
            <div class="ports-row">
                <div class="port-block"></div>
                <div class="port-block"></div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="funcGen2" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">Frequency: <span id="funcFreq2Val">2.5</span> MHz</div>
                <button onclick="changeFrequency('func2', -0.5)" id="func2FreqDownBtn">-</button>
                <button onclick="changeFrequency('func2', 0.5)" id="func2FreqUpBtn">+</button>
            </div>
            <div class="control-group">
                <div class="control-label">Amplitude: <span id="funcAmp2Val">15</span> V</div>
                <button onclick="changeAmplitude('func2', -1)" id="func2AmpDownBtn">-</button>
                <button onclick="changeAmplitude('func2', 1)" id="func2AmpUpBtn">+</button>
            </div>
        </div>

        <!-- Binary Input & NRZ Square Wave -->
        <div class="module" id="binaryModule">
            <h2>Binary Input (NRZ Data)</h2>
            <div id="binaryInput" title="Toggle bits 0 or 1">
                <label><input type="checkbox" data-bit="7" />7</label>
                <label><input type="checkbox" data-bit="6" />6</label>
                <label><input type="checkbox" data-bit="5" />5</label>
                <label><input type="checkbox" data-bit="4" />4</label>
                <label><input type="checkbox" data-bit="3" />3</label>
                <label><input type="checkbox" data-bit="2" />2</label>
                <label><input type="checkbox" data-bit="1" />1</label>
                <label><input type="checkbox" data-bit="0" />0</label>
            </div>
            <div class="ports-row" style="margin-top: 15px;">
               
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="binaryModule" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
        </div>

        <!-- Balanced Modulator 1 -->
        <div class="module" id="balMod1">
            <h2>Modulator 1 (Mark)</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="balMod1" data-index="0"
                        data-input="signal"></div>
                    <div class="port-label">Signal</div>
                </div>
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="balMod1" data-index="1"
                        data-input="carrier"></div>
                    <div class="port-label">Carrier</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="balMod1" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
        </div>

        <!-- Balanced Modulator 2 -->
        <div class="module" id="balMod2">
            <h2>Modulator 2 (Space)</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="balMod2" data-index="0"
                        data-input="signal"></div>
                    <div class="port-label">Input</div>
                </div>
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="balMod2" data-index="1"
                        data-input="carrier"></div>
                    <div class="port-label">Carrier</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="balMod2" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
        </div>

        <!-- NOT Gate -->
        <div class="module" id="notGate">
            <h2>NOT Gate</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="notGate" data-index="0"></div>
                    <div class="port-label">Input</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="notGate" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
        </div>

        <!-- Summing Amplifier -->
        <div class="module" id="summingAmplifier">
            <h2>Summing Amplifier</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="summingAmplifier" data-index="0"></div>
                    <div class="port-label">Input 1</div>
                </div>
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="summingAmplifier" data-index="1"></div>
                    <div class="port-label">Input 2</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="summingAmplifier" data-index="0">
                    </div>
                    <div class="port-label">Output</div>
                </div>
            </div>
        </div>
    </div>
    
   

    <script>
        // State
        let powerOn = false;
        let selectedPort = null;
        let connections = [];
        let tempConnection = null;

        let inputsLocked = false;

        // Parameters for function generators only
        let func1 = { freq: 2, amp: 15, freqMax: 60, unit: 'MHz', color: 'orange' };
        let func2 = { freq: 2.5, amp: 15, freqMax: 60, unit: 'MHz', color: 'purple' };

        // Elements
        const powerBtn = document.getElementById('powerBtn');
        const resetConnectionsBtn = document.getElementById('resetConnectionsBtn');
        const showOscilloscopeBtn = document.getElementById('showOscilloscopeBtn');
        const statusMessage = document.getElementById('statusMessage');
        // const bfskOutput = document.getElementById('bfskOutput');

        const funcFreq1Val = document.getElementById('funcFreq1Val');
        const funcAmp1Val = document.getElementById('funcAmp1Val');
        const funcFreq2Val = document.getElementById('funcFreq2Val');
        const funcAmp2Val = document.getElementById('funcAmp2Val');

      
        // Oscilloscope elements
        const oscilloscopeModal = document.getElementById('oscilloscopeModal');
        const oscilloscopeClose = document.getElementById('oscilloscopeClose');
        const oscilloscopeDisplay = document.getElementById('oscilloscopeDisplay');
        const oscilloscopeCtx = oscilloscopeDisplay.getContext('2d');
        const waveformInput = document.getElementById('inputWave');
        const waveformFunc1 = document.getElementById('funcGen1Wave');
        const waveformFunc2 = document.getElementById('funcGen2Wave');
        const waveformOutput = document.getElementById('outputWave');

        // Binary Input bits state, 8 bits
        const binaryBits = new Array(8).fill(false);

        // Setup canvas size for responsiveness
        // function resizeCanvas() {
        //     bfskCanvas.width = Math.min(window.innerWidth - 20, 1400);
        //     bfskCanvas.height = 100;
            
        //     oscilloscopeDisplay.width = document.getElementById('oscilloscopeContent').offsetWidth - 40;
        //     oscilloscopeDisplay.height = 300;
        // }
        // resizeCanvas();


        function resizeCanvas() {            
    oscilloscopeDisplay.width = document.getElementById('oscilloscopeContent').offsetWidth - 40;
    oscilloscopeDisplay.height = 300;
}

        window.addEventListener('resize', () => {
            resizeCanvas();
            drawFinalBFSKWaveform();
            if (oscilloscopeModal.style.display === 'block') {
                drawOscilloscope();
            }
        });

        // Oscilloscope functionality
        showOscilloscopeBtn.onclick = () => {
            if (!powerOn) {
                showStatus("Please turn power ON first");
                return;
            }
            
            oscilloscopeModal.style.display = 'flex';
            drawOscilloscope();
        };

        oscilloscopeClose.onclick = () => {
            oscilloscopeModal.style.display = 'none';
        };

        window.onclick = (event) => {
            if (event.target === oscilloscopeModal) {
                oscilloscopeModal.style.display = 'none';
            }
        };

        // Add event listeners for waveform selection
        waveformInput.addEventListener('change', drawOscilloscope);
        waveformFunc1.addEventListener('change', drawOscilloscope);
        waveformFunc2.addEventListener('change', drawOscilloscope);
        waveformOutput.addEventListener('change', drawOscilloscope);

        function drawOscilloscope() {
            const canvasW = oscilloscopeDisplay.width;
            const canvasH = oscilloscopeDisplay.height;
            
            // Clear the display with a dark background
            oscilloscopeCtx.fillStyle = '#111';
            oscilloscopeCtx.fillRect(0, 0, canvasW, canvasH);
            
            // Draw grid with brighter lines
            oscilloscopeCtx.strokeStyle = '#333';
            oscilloscopeCtx.lineWidth = 1;
            
            // Vertical grid lines
            for (let x = 0; x < canvasW; x += canvasW / 10) {
                oscilloscopeCtx.beginPath();
                oscilloscopeCtx.moveTo(x, 0);
                oscilloscopeCtx.lineTo(x, canvasH);
                oscilloscopeCtx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y < canvasH; y += canvasH / 8) {
                oscilloscopeCtx.beginPath();
                oscilloscopeCtx.moveTo(0, y);
                oscilloscopeCtx.lineTo(canvasW, y);
                oscilloscopeCtx.stroke();
            }
            
            // Center line (brighter)
            oscilloscopeCtx.strokeStyle = '#666';
            oscilloscopeCtx.beginPath();
            oscilloscopeCtx.moveTo(0, canvasH/2);
            oscilloscopeCtx.lineTo(canvasW, canvasH/2);
            oscilloscopeCtx.stroke();
            
            // Determine which waveform to show
            let selectedWaveform = 'input';
            if (waveformInput.checked) selectedWaveform = 'input';
            if (waveformFunc1.checked) selectedWaveform = 'func1';
            if (waveformFunc2.checked) selectedWaveform = 'func2';
            if (waveformOutput.checked) selectedWaveform = 'output';
            
            // Set waveform color based on selection
            let waveColor = '#0f0'; // Green
            if (selectedWaveform === 'func1') waveColor = func1.color;
            if (selectedWaveform === 'func2') waveColor = func2.color;
            if (selectedWaveform === 'output') waveColor = 'purple';
            
            oscilloscopeCtx.strokeStyle = waveColor;
            oscilloscopeCtx.lineWidth = 2;
            oscilloscopeCtx.beginPath();
            
            const bits = binaryBits;
            const bitWidth = canvasW / bits.length;
            const pointsPerBit = 100;
            
            if (selectedWaveform === 'input') {
                // Draw NRZ input signal
                const highY = canvasH / 4;
                const lowY = (canvasH / 4) * 3;
                
                let x = 0;
                oscilloscopeCtx.moveTo(x, bits[0] ? highY : lowY);

                for (let i = 0; i < bits.length; i++) {
                    x = i * bitWidth;
                    oscilloscopeCtx.lineTo(x, bits[i] ? highY : lowY);
                    oscilloscopeCtx.lineTo(x + bitWidth, bits[i] ? highY : lowY);
                }
            } 
            else if (selectedWaveform === 'func1') {
                // Draw Function Generator 1 waveform
                for (let i = 0; i < bits.length; i++) {
                    for (let p = 0; p <= pointsPerBit; p++) {
                        const x = i * bitWidth + (p / pointsPerBit) * bitWidth;
                        const angle = 2 * Math.PI * func1.freq * (p / pointsPerBit) * 2;
                        const y = canvasH / 2 - Math.sin(angle) * ((func1.amp / 40) * (canvasH/2 - 10));

                        if (i === 0 && p === 0) {
                            oscilloscopeCtx.moveTo(x, y);
                        } else {
                            oscilloscopeCtx.lineTo(x, y);
                        }
                    }
                }
            }
            else if (selectedWaveform === 'func2') {
                // Draw Function Generator 2 waveform
                for (let i = 0; i < bits.length; i++) {
                    for (let p = 0; p <= pointsPerBit; p++) {
                        const x = i * bitWidth + (p / pointsPerBit) * bitWidth;
                        const angle = 2 * Math.PI * func2.freq * (p / pointsPerBit) * 2;
                        const y = canvasH / 2 - Math.sin(angle) * ((func2.amp / 40) * (canvasH/2 - 10));

                        if (i === 0 && p === 0) {
                            oscilloscopeCtx.moveTo(x, y);
                        } else {
                            oscilloscopeCtx.lineTo(x, y);
                        }
                    }
                }
            }
            else if (selectedWaveform === 'output') {
                // Only draw BFSK output if all connections are made
                const allConnectionsMade = checkAllConnections();
                if (!allConnectionsMade) return;
                
                // Draw BFSK output waveform
                for (let i = 0; i < bits.length; i++) {
                    const freq = bits[i] ? func1.freq : func2.freq;
                    const amp = bits[i] ? func1.amp : func2.amp;
                    
                    for (let p = 0; p <= pointsPerBit; p++) {
                        const x = i * bitWidth + (p / pointsPerBit) * bitWidth;
                        const angle = 2 * Math.PI * freq * (p / pointsPerBit) * 2;
                        const y = canvasH / 2 - Math.sin(angle) * ((amp / 40) * (canvasH/2 - 10));

                        if (i === 0 && p === 0) {
                            oscilloscopeCtx.moveTo(x, y);
                        } else {
                            oscilloscopeCtx.lineTo(x, y);
                        }
                    }
                }
            }
            
            oscilloscopeCtx.stroke();
            
            
            
            // Add time markers
            oscilloscopeCtx.fillStyle = 'yellow';
            oscilloscopeCtx.font = '12px Arial';
            for (let i = 0; i <= bits.length; i++) {
                const x = i * bitWidth;
                oscilloscopeCtx.fillText(i.toString(), x - 5, canvasH - 10);
            }
        }

        // Power toggle function
        powerBtn.onclick = () => {
            powerOn = !powerOn;
            // Update button appearance
            powerBtn.textContent = powerOn ? "Power OFF" : "Power ON";
            powerBtn.className = powerOn ? "on" : "off";
            // Update system state
            updateBFSKOutput();
        };

        // Initialize button state
        powerBtn.className = "off"; // Start in OFF (red) state

        // Reset connections and unlock inputs
        resetConnectionsBtn.onclick = () => {
            connections.forEach(conn => {
                document.getElementById('kit').removeChild(conn.element);
                if (conn.label) document.getElementById('kit').removeChild(conn.label);
            });
            connections = [];
            inputsLocked = false;
            enableInputs(true);
            updateBFSKOutput();
        };

        function showStatus(message, isError = true) {
            statusMessage.textContent = message;
            statusMessage.style.backgroundColor = isError ? '#f44336' : '#4CAF50';
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 2000);
        }

        // Disable or enable all inputs and frequency/amp controls based on locked state
        function enableInputs(enable) {
            const allCheckboxes = document.querySelectorAll('#binaryInput input[type="checkbox"]');
            allCheckboxes.forEach(cb => cb.disabled = !enable);

            // Disable/enable the function generator buttons
            document.getElementById('func1FreqDownBtn').disabled = !enable;
            document.getElementById('func1FreqUpBtn').disabled = !enable;
            document.getElementById('func1AmpDownBtn').disabled = !enable;
            document.getElementById('func1AmpUpBtn').disabled = !enable;
            document.getElementById('func2FreqDownBtn').disabled = !enable;
            document.getElementById('func2FreqUpBtn').disabled = !enable;
            document.getElementById('func2AmpDownBtn').disabled = !enable;
            document.getElementById('func2AmpUpBtn').disabled = !enable;
        }

        // Port events for mouse and touch
        document.querySelectorAll('.port').forEach(port => {
            port.addEventListener('mousedown', function (e) { portDownHandler(e, this); });
            port.addEventListener('touchstart', function (e) { portDownHandler(e, this); }, {passive: false});
        });

        function portDownHandler(e, portElem) {
            e.preventDefault();
            e.stopPropagation();

            if (!inputsLocked) {
                // Before locking inputs, ensure binary input is given (at least one bit set)
                if (!validateUserInputs()) {
                    showStatus("Please provide binary input and set function generator parameters before making connections");
                    return;
                }
            }

            if (!inputsLocked) {
                // Lock inputs on first successful connection attempt
                inputsLocked = true;
                enableInputs(false);
            }

            document.querySelectorAll('.port').forEach(p => p.classList.remove('selected'));

            portElem.classList.add('selected');
            selectedPort = portElem;

            if (portElem.getAttribute('data-type') === 'output') {
                if (e.type === 'mousedown') {
                    document.addEventListener('mousemove', moveTempConnection);
                    document.addEventListener('mouseup', releaseTempConnection);
                } else if (e.type === 'touchstart') {
                    document.addEventListener('touchmove', moveTempConnectionTouch, {passive: false});
                    document.addEventListener('touchend', releaseTempConnectionTouch);
                    document.addEventListener('touchcancel', releaseTempConnectionTouch);
                }
            }
        }

        // Validate binary input and function generator params before allowing connections
        function validateUserInputs() {
            // Validate binary input at least one checked
            const binaryCheckboxes = document.querySelectorAll('#binaryInput input[type="checkbox"]');
            let binarySet = false;
            for (let cb of binaryCheckboxes) {
                if (cb.checked) {
                    binarySet = true;
                    break;
                }
            }
            if (!binarySet) return false;

            // Validate function generator frequency and amplitude are positive non-zero
            if (func1.freq <= 0 || func2.freq <= 0) return false;
            if (func1.amp <= 0 || func2.amp <= 0) return false;
            return true;
        }

        function moveTempConnection(e) {
            if (!selectedPort || selectedPort.getAttribute('data-type') !== 'output') return;
            const kit = document.getElementById('kit');
            const kitRect = kit.getBoundingClientRect();
            const portRect = selectedPort.getBoundingClientRect();

            const startX = portRect.left + portRect.width / 2 - kitRect.left;
            const startY = portRect.top + portRect.height / 2 - kitRect.top;
            const endX = e.clientX - kitRect.left;
            const endY = e.clientY - kitRect.top;

            if (!tempConnection) {
                tempConnection = document.createElement('div');
                tempConnection.className = 'temp-connection';
                kit.appendChild(tempConnection);
            }

            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;

            tempConnection.style.left = startX + 'px';
            tempConnection.style.top = startY + 'px';
            tempConnection.style.width = length + 'px';
            tempConnection.style.transform = 'rotate(' + angle + 'deg)';
        }

        function moveTempConnectionTouch(e) {
            e.preventDefault();
            if (!selectedPort || selectedPort.getAttribute('data-type') !== 'output') return;
            const touch = e.touches[0];
            if (!touch) return;
            const kit = document.getElementById('kit');
            const kitRect = kit.getBoundingClientRect();
            const portRect = selectedPort.getBoundingClientRect();

            const startX = portRect.left + portRect.width / 2 - kitRect.left;
            const startY = portRect.top + portRect.height / 2 - kitRect.top;
            const endX = touch.clientX - kitRect.left;
            const endY = touch.clientY - kitRect.top;

            if (!tempConnection) {
                tempConnection = document.createElement('div');
                tempConnection.className = 'temp-connection';
                kit.appendChild(tempConnection);
            }

            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;

            tempConnection.style.left = startX + 'px';
            tempConnection.style.top = startY + 'px';
            tempConnection.style.width = length + 'px';
            tempConnection.style.transform = 'rotate(' + angle + 'deg)';
        }

        function releaseTempConnection(e) {
            document.removeEventListener('mousemove', moveTempConnection);
            document.removeEventListener('mouseup', releaseTempConnection);

            if (tempConnection) {
                document.getElementById('kit').removeChild(tempConnection);
                tempConnection = null;
            }

            if (!selectedPort) return;

            const hoveredElement = document.elementFromPoint(e.clientX, e.clientY);
            const targetPort = hoveredElement?.closest('.port');

            if (targetPort && targetPort !== selectedPort) {
                tryCreateConnection(selectedPort, targetPort);
            } else {
                showStatus("Incomplete connection");
            }

            selectedPort.classList.remove('selected');
            selectedPort = null;
        }

        function releaseTempConnectionTouch(e) {
            e.preventDefault();
            document.removeEventListener('touchmove', moveTempConnectionTouch);
            document.removeEventListener('touchend', releaseTempConnectionTouch);
            document.removeEventListener('touchcancel', releaseTempConnectionTouch);

            if (tempConnection) {
                document.getElementById('kit').removeChild(tempConnection);
                tempConnection = null;
            }

            if (!selectedPort) return;

            // Use the touchend location to detect target port
            let touch = e.changedTouches ? e.changedTouches[0] : null;
            if (!touch) {
                selectedPort.classList.remove('selected');
                selectedPort = null;
                return;
            }

            const targetPortElem = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.port');

            if (targetPortElem && targetPortElem !== selectedPort) {
                tryCreateConnection(selectedPort, targetPortElem);
            } else {
                showStatus("Incomplete connection");
            }

            selectedPort.classList.remove('selected');
            selectedPort = null;
        }


        function tryCreateConnection(sourcePort, targetPort) {
            const sourceType = sourcePort.getAttribute('data-type');
            const targetType = targetPort.getAttribute('data-type');

            if (sourceType !== 'output' || targetType !== 'input') {
                showStatus("Can only connect output to input");
                return false;
            }

            const targetModule = targetPort.getAttribute('data-module');
            const targetIndex = targetPort.getAttribute('data-index');

            if (connections.some(conn =>
                conn.targetModule === targetModule && conn.targetIndex === targetIndex
            )) {
                showStatus("Input port already connected");
                return false;
            }

            const sourceModule = sourcePort.getAttribute('data-module');
            const sourceIndex = sourcePort.getAttribute('data-index');
            const targetInputType = targetPort.getAttribute('data-input');

            let isValid = false;
            let errorMessage = "Invalid connection for BFSK circuit";

            if ((sourceModule === 'funcGen1') && sourceIndex === '0') {
                isValid = (targetModule === 'balMod1' && targetInputType === 'carrier');
                errorMessage = "Function Generator 1 must connect to Modulator1's carrier input";
            }
            else if ((sourceModule === 'funcGen2') && sourceIndex === '0') {
                isValid = (targetModule === 'balMod2' && targetInputType === 'carrier');
                errorMessage = "Function Generator 2 must connect to Modulator2's carrier input";
            }
            else if (sourceModule === 'binaryModule' && sourceIndex === '0') {
                isValid = (targetModule === 'balMod1' && targetInputType === 'signal') ||
                    (targetModule === 'notGate' && targetIndex === '0');
                errorMessage = "Binary output must connect to Modulator1's signal input or NOT gate";
            }
            else if (sourceModule === 'notGate' && sourceIndex === '0') {
                isValid = (targetModule === 'balMod2' && targetInputType === 'signal');
                errorMessage = "NOT gate must connect to Modulator2's signal input";
            }
            else if ((sourceModule === 'balMod1' || sourceModule === 'balMod2') && sourceIndex === '0') {
                isValid = (targetModule === 'summingAmplifier' && (targetIndex === '0' || targetIndex === '1'));
                errorMessage = "Modulator outputs must connect to Summing Amplifier";
            }
            else if (sourceModule === 'summingAmplifier' && sourceIndex === '0') {
                isValid = false;
                errorMessage = "Summing Amplifier output is the final BFSK output";
            }

            if (!isValid) {
                showStatus(errorMessage);
                return false;
            }

            createConnection(sourcePort, targetPort);
            showStatus("Connection successful!", false);
            updateBFSKOutput();
            return true;
        }

        function createConnection(sourcePort, targetPort) {
            const kit = document.getElementById('kit');
            const kitRect = kit.getBoundingClientRect();
            const sourceRect = sourcePort.getBoundingClientRect();
            const targetRect = targetPort.getBoundingClientRect();

            const sourceX = sourceRect.left + sourceRect.width / 2 - kitRect.left;
            const sourceY = sourceRect.top + sourceRect.height / 2 - kitRect.top;
            const targetX = targetRect.left + targetRect.width / 2 - kitRect.left;
            const targetY = targetRect.top + targetRect.height / 2 - kitRect.top;

            const connection = document.createElement('div');
            connection.className = 'connection';
            connection.style.left = sourceX + 'px';
            connection.style.top = sourceY + 'px';

            const length = Math.sqrt(Math.pow(targetX - sourceX, 2) + Math.pow(targetY - sourceY, 2));
            const angle = Math.atan2(targetY - sourceY, targetX - sourceX) * 180 / Math.PI;

            connection.style.width = length + 'px';
            connection.style.transform = 'rotate(' + angle + 'deg)';

            kit.appendChild(connection);

            connection.addEventListener('click', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    kit.removeChild(connection);
                    if (connection.label) kit.removeChild(connection.label);
                    connections = connections.filter(conn => conn.element !== connection);
                    updateBFSKOutput();
                }
            });

            connections.push({
                sourceModule: sourcePort.getAttribute('data-module'),
                sourceIndex: sourcePort.getAttribute('data-index'),
                targetModule: targetPort.getAttribute('data-module'),
                targetIndex: targetPort.getAttribute('data-index'),
                element: connection
            });
        }

        // Check if all required connections are made
        function checkAllConnections() {
            const hasFunc1ToMod1 = connections.some(conn =>
                conn.sourceModule === 'funcGen1' && conn.targetModule === 'balMod1' && conn.targetIndex === '1');

            const hasBinaryToMod1 = connections.some(conn =>
                conn.sourceModule === 'binaryModule' && conn.targetModule === 'balMod1' && conn.targetIndex === '0');

            const hasFunc2ToMod2 = connections.some(conn =>
                conn.sourceModule === 'funcGen2' && conn.targetModule === 'balMod2' && conn.targetIndex === '1');

            const hasBinaryToNot = connections.some(conn =>
                conn.sourceModule === 'binaryModule' && conn.targetModule === 'notGate' && conn.targetIndex === '0');

            const hasNotToMod2 = connections.some(conn =>
                conn.sourceModule === 'notGate' && conn.targetModule === 'balMod2' && conn.targetIndex === '0');

            const hasMod1ToSum = connections.some(conn =>
                conn.sourceModule === 'balMod1' && conn.targetModule === 'summingAmplifier');

            const hasMod2ToSum = connections.some(conn =>
                conn.sourceModule === 'balMod2' && conn.targetModule === 'summingAmplifier');

            return hasFunc1ToMod1 && hasBinaryToMod1 && hasFunc2ToMod2 &&
                hasBinaryToNot && hasNotToMod2 && hasMod1ToSum && hasMod2ToSum;
        }

        function updateBFSKOutput() {
            const allConnectionsMade = checkAllConnections();

            // Implementation for BFSK output update removed as per original comments
        }

        function changeFrequency(gen, delta) {
            if (inputsLocked) {
                showStatus("Reset connections to modify parameters");
                return;
            }
            if (gen === 'func1') {
                func1.freq = Math.min(Math.max(func1.freq + delta, 0.1), func1.freqMax);
                funcFreq1Val.textContent = func1.freq.toFixed(2);
            } else if (gen === 'func2') {
                func2.freq = Math.min(Math.max(func2.freq + delta, 0.1), func2.freqMax);
                funcFreq2Val.textContent = func2.freq.toFixed(2);
            }
        }

        function changeAmplitude(gen, delta) {
            if (inputsLocked) {
                showStatus("Reset connections to modify parameters");
                return;
            }
            if (gen === 'func1') {
                func1.amp = Math.min(Math.max(func1.amp + delta, 0), 40);
                funcAmp1Val.textContent = func1.amp.toFixed(1);
            } else if (gen === 'func2') {
                func2.amp = Math.min(Math.max(func2.amp + delta, 0), 40);
                funcAmp2Val.textContent = func2.amp.toFixed(1);
            }
        }

        // Forbid binary inputs change after locking
        document.querySelectorAll('#binaryInput input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', (e) => {
                if (inputsLocked) {
                    e.preventDefault();
                    cb.checked = binaryBits[parseInt(cb.getAttribute('data-bit'))];
                    showStatus("Reset connections to change binary input");
                    return;
                }
                const bitIndex = parseInt(cb.getAttribute('data-bit'));
                binaryBits[bitIndex] = cb.checked;
                if (powerOn) {
                    updateBFSKOutput();
                }
            });
        });

        funcFreq1Val.textContent = func1.freq.toFixed(2);
        funcAmp1Val.textContent = func1.amp.toFixed(1);
        funcFreq2Val.textContent = func2.freq.toFixed(2);
        funcAmp2Val.textContent = func2.amp.toFixed(1);

    </script>

</body>

</html>

